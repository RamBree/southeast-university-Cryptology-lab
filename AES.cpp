//Nb=4 Nk=4 Nr=10
//用int型来表示一个字节（仅使用其后8位），直接对16个8bit的数组进行加密
#include <iostream>
using namespace std;

int Nb = 4, Nk = 4, Nr=10;	
int K[50];
bool byteclomn[8][8] = { {1,0,0,0,1,1,1,1},
						 {1,1,0,0,0,1,1,1},
						 {1,1,1,0,0,0,1,1},
						 {1,1,1,1,0,0,0,1},
						 {1,1,1,1,1,0,0,0},
						 {0,1,1,1,1,1,0,0},
						 {0,0,1,1,1,1,1,0},
						 {0,0,0,1,1,1,1,1} };
bool addcolumn[8] = { 1,1,0,0,0,1,1,0 };
int mixcolumn[4][4] = { {0x02,0x03,0x01,0x01},
						{0x01,0x02,0x03,0x01},
						{0x01,0x01,0x02,0x03},
						{0x03,0x01,0x01,0x02} };
int decolumn[4][4] = { 0xe, 0xb, 0xd, 0x9,
	                   0x9, 0xe, 0xb, 0xd,
					   0xd, 0x9, 0xe, 0xb,
					   0xb, 0xd, 0x9, 0xe };//逆矩阵
int A[4][10];
int Ade[4][10];//
int Bde[4][10];//解密用
//S盒
int S[16][16] = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
//逆S盒
int S2[16][16] = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
int ShiftC[4] = { 0,1,2,3 };
int Rcon[12] = { 0x00000000 , 0x01000000, 0x02000000,
	             0x04000000, 0x08000000,
	             0x10000000, 0x20000000,
	             0x40000000, 0x80000000,
	             0x1b000000, 0x36000000 };
int W[60];
int g(int a, int k)
{
	int temp[4];
	for (int i = 0; i < 3; i++)
	{
		temp[i] = 0x000000ff & (a >> (16 - 8 * i));
	}
	temp[3] = (a >> 24) & 0x000000ff;//移位加取出
	for (int i = 0; i < 4; i++)
	{
		int temp1 = (temp[i] & 0x000000f0)>>4;
		int temp2 = temp[i] & 0x0000000f;//前后四位
		temp[i] = S[temp1][temp2];
	}//s盒置换
	int ans = (temp[0] << 24) | (temp[1] << 16) | (temp[2] << 8) | (temp[3]);
	return ans ^ Rcon[k];
}

void KeyExpansion()
{
	for (int i = 0; i < Nk; i++)
		W[i] = (K[4 * i + 0] << 24) | (K[4 * i + 1] << 16) | (K[4 * i + 2] << 8) | (K[4 * i + 3]);
	for (int i = 4; i < Nb * (Nr+1); i++)
	{
		if (i % Nk == 0)
			W[i] = W[i - 4] ^ g(W[i - 1], i / Nk);
		else
			W[i] = W[i - 4] ^ W[i - 1];
	}
}
void Init()
{
	cout << "输入16个8bit的数" << endl;
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < Nb; j++)
			cin >> A[i][j],Ade[i][j]=A[i][j];
	cout << "输入16个8bit的密钥" << endl;
	for (int i = 0; i < Nk; i++)
		for (int j = 0; j < 4; j++)
			cin >> K[4 * i + j];
	KeyExpansion();
}
void Bytesub()
{
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
		{
            int temp1 = (Ade[i][j] & 0x000000f0)>>4;
            int temp2 = Ade[i][j] & 0x0000000f;//前后四位
	        Ade[i][j] = S[temp1][temp2];
		}
}
void InvBytesub()
{
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
		{
			int temp1 = (Bde[i][j] & 0x000000f0)>>4;
			int temp2 = Bde[i][j] & 0x0000000f;//前后四位
			Bde[i][j] = S2[temp1][temp2];
		}
}
void ShiftRow()
{
	int temp[4][4];
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
		{
			temp[i][j] = Ade[i][(j + ShiftC[i]) % 4];
		}
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			Ade[i][j] = temp[i][j];
}
void InvShiftRow()
{
	int temp[4][4];
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
		{
			temp[i][j] = Bde[i][(j - ShiftC[i] + 4) % 4];
		}
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
		    Bde[i][j] = temp[i][j];
}
int GFMul2(int s) {
	int ans = s << 1;
	int a7 = ans & 0x00000100;//进位了
	if (a7 != 0) {
		ans = ans & 0x000000ff;
		ans = ans ^ 0x0000001b;
	}//(b7b6b5b4b3b2b1b0)×'02'=(b6b5b4b3b2b1b00)+(000b7b70b7b7)；
	return ans;
}
int GFMul3(int s) {
	return GFMul2(s) ^ s;
}
int GFMul4(int s) {
	return GFMul2(GFMul2(s));
}
int GFMul8(int s) {
	return GFMul2(GFMul4(s));
}
int GFMul9(int s) {
	return GFMul8(s) ^ s;
}
int GFMul11(int s) {
	return GFMul9(s) ^ GFMul2(s);
}
int GFMul12(int s) {
	return GFMul8(s) ^ GFMul4(s);
}
int GFMul13(int s) {
	return GFMul12(s) ^ s;
}
int GFMul14(int s) {
	return GFMul12(s) ^ GFMul2(s);
}
int GF(int n, int s) {// 基于有限域GF（2）的乘法运算
	int result=0;
	if (n == 1)
		result = s;
	else if (n == 2)
		result = GFMul2(s);
	else if (n == 3)
		result = GFMul3(s);
	else if (n == 0x9)
		result = GFMul9(s);
	else if (n == 0xb)//11
		result = GFMul11(s);
	else if (n == 0xd)//13
		result = GFMul13(s);
	else if (n == 0xe)//14
		result = GFMul14(s);//递归运算定义
	return result;
}
void MixColumn() {

	int temp[4][4];
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < Nb; j++)
			temp[i][j] = Ade[i][j];

	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++) {
			Ade[i][j] = GF(mixcolumn[i][0], temp[0][j]) ^ GF(mixcolumn[i][1], temp[1][j])
				^ GF(mixcolumn[i][2], temp[2][j]) ^ GF(mixcolumn[i][3], temp[3][j]);//02∙𝐷𝐵⨁03∙13⨁01∙53⨁01∙45
		}
}
void InvMixColumn() {

	int temp[4][4];
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < Nb; j++)
			temp[i][j] = Bde[i][j];

	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++) {
			Bde[i][j] = GF(decolumn[i][0], temp[0][j]) ^ GF(decolumn[i][1], temp[1][j])
				^ GF(decolumn[i][2], temp[2][j]) ^ GF(decolumn[i][3], temp[3][j]);//02∙𝐷𝐵⨁03∙13⨁01∙53⨁01∙45
		}
}
void AddRoundKey(int k)
{
		int temp[4];
		for (int i = 0; i < 4; i++) {//Nk个
			for (int j = 0; j < 4; j++)
			{
				temp[j] = (W[4 * k + i] >> (24-8 * j)) & 0x000000ff;
			}
            // 将一个字的K分解成4个8bit的k
			for (int j = 0; j < 4; j++) {
				Ade[j][i] = Ade[j][i] ^ temp[j];
			}
		}
}
void BAddRoundKey(int k)
{	int temp[4][4];		
    int temp2[4][4];
		for (int i = 0; i < 4; i++) {//Nk个
			for (int j = 0; j < 4; j++)
			{
				temp[j][i] = (W[4 * k + i] >> (24 - 8 * j)) & 0x000000ff;// 将一个字的K分解成4个8bit的k
			}
		}

		if (k != 0 && k != 10)
		{
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < Nb; j++)
					temp2[i][j] = temp[i][j];
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 4; j++) {
					temp[i][j] = GF(decolumn[i][0], temp2[0][j]) ^ GF(decolumn[i][1], temp2[1][j])
						^ GF(decolumn[i][2], temp2[2][j]) ^ GF(decolumn[i][3], temp2[3][j]);//02∙𝐷𝐵⨁03∙13⨁01∙53⨁01∙45
				}//将密钥混合
		}


	for (int i = 0; i < 4; i++) {//Nk个
		for (int j = 0; j < 4; j++) {
			Bde[i][j] = Bde[i][j] ^ temp[i][j];
		}
	}
}
void Round(int k)
{
	 Bytesub();
	 ShiftRow();
	 MixColumn();
	 AddRoundKey(k);
}
void FinalRound()
{
	Bytesub();
	ShiftRow();
	AddRoundKey(10);
}
void InvRound(int k)
{
	InvBytesub();
	InvShiftRow();
	InvMixColumn();
	BAddRoundKey(k);
}
void InvFinalRound()
{
	InvBytesub();
	InvShiftRow();
	BAddRoundKey(0);
}

void EnCode()
{
	AddRoundKey(0);
	for (int k = 1; k <= Nr - 1; k++)
		Round(k);
	FinalRound();
}
void Show()
{
	cout << "加密后：" << endl;
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < Nb; j++)
		{
			Bde[i][j] = Ade[i][j];
			cout << Ade[i][j] << " ";
		}
		cout << '\n';
	}//show
}
void DeCode()
{
	BAddRoundKey(10);
	for (int k = Nr-1; k > 0; k--)
		InvRound(k);
	InvFinalRound();
}
int main()
{
	Init();//初始化
	EnCode();//加密
	Show();//
	DeCode();//解密
	cout << "解密后：" << endl;
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < Nb; j++)
		{
			cout << Bde[i][j] << " ";
		}
		cout << '\n';
	}
	return 0;
}